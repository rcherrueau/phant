#+TITLE: Union Types in Scala via the Curry-Howard isomorphism
#+STARTUP: entitiespretty
#+OPTIONS: ^:{}

See http://www.chuusai.com/2011/06/09/scala-union-types-curry-howard/

How we can encode union types in Scala. A union type is the union of
two (or more) types. The values of that types are all of the values
of each of the types that it's the union of.

What does this mean concretely? It means that id we could express
union type directly in Scala we would be able to write,

#+BEGIN_SRC scala
def size(x: Int ∨ String) = x match {
  case i: Int => i
  case s: String => s.length
}

size(23)    // Type checks
size("foo") // Type checks
size(1.0)   // Doesn't type check
#+END_SRC

It's important to recognize the difference between this use of a union
type and the similar use of Scala Either. Either is a *sum type*, the
analog of union types in type theory. And the main disavantage is
Either don't support subtyping.

#+BEGIN_SRC scala
def size(x: Either[Int, String]) = x match {
  case Left(i) => i
  case Right(s) => s.length
}

size(Left(23))
size(Right("foo"))
#+END_SRC

There is an isomorphism between =Either[Int, String]= and =(Int ∨
String)=. But the Either type manages this by way of a layer of boxed
representation, rather then by being an unboxed primitive feature of
the type system.

Can we do better than Either? Can we find a way of representing union
types in Scala which doesn't require boxing, and which provides all of
the static guarantees we would expect?

It turns out that we can, but to get there we have take a detour
through first-order logic via the [[http://en.wikipedia.org/wiki/Curry%25E2%2580%2593Howard_correspondence][Curry-Howard isomorphism]].
Curry-Howard tells us that the relationships between types in a type
system can be viewed as an image of the relationships between
propositions in a logical system (and vice versa).

To illustrate Curry-Howard (in the context of a type system with
subtyping like Scala's), we can see that there is a correspondence
between intersection types (=A with B= in scala) and logical
conjunction (=A ∧ B=); between the hypothetical union types (=A ∨ B=)
and logical disjunction (also =A ∨ B=); and between subtyping (=A <:
B=) and logical implication (=A ⇒ B=). On the left hand side of each
row in the table below we have a subtype relationship which is valid
in Scala.

| Scala           | First Order Logic |
|-----------------+-------------------|
| (A with B) <: A | (A ∧ B) ⇒ A       |
| (A with B) <: B | (A ∧ B) ⇒ B       |
| A <: (A ∨ B)    | A ⇒ (A ∨ B)       |
| B <: (A ∨ B)    | B ⇒ (A ∨ B)       |

The essence of Curry-Howard is that this mechanical rewriting process
(whichever direction you go in) will always preserve validity -- valid
type formulae will always rewrite to valid logical formulae, and vice
versa. This isn't only true for conjunction, disjunction and
implication. We can also generalize the correspondence to logical
formulae which include negation of a type =A= (I'll write it as
=¬[A]=) to have as it's values everything which isn't an instance of
=A=. This is also something which can't be directly expressed in Scala,
but suppose it was?

If it was, then we would be able to crank on the Curry-Howard
isomorphism and [[http://en.wikipedia.org/wiki/De_Morgan%2527s_laws][De Morgan's laws]] to give us a definition of union
types in terms of interserction types (A with B) and type negation.
Here's how that might go ...

First recall the De Morgan equivalence,

#+BEGIN_VERSE
(A \lor B) \Leftrightarrow ¬(¬A \land ¬B)
#+END_VERSE

Now apply Curry-Howard (using Scala's ~=:=~ type equality operator).

#+BEGIN_SRC scala
(A ∨ B) =:= ¬[¬[A] with ¬[B]]
#+END_SRC

If we could work out a way of expressing this in Scala, we'd be home
and dry and have our union types. So can we express type negation?

Unfortunately we can't. But what we can do is transform all of our
types in a way which allows negation to be expressed in the
transformed context. We'll then need to work out how make that work
for us back in the original untransformed context.

Some readers might have been a little surprised earlier when I
illustrated Curry-Howard using intersection types as the correlate of
conjuction, union types as the correlate of disjunction and the
subtypes relation as the correlate of implication. That's not how it's
noramlly done -- usually product types (ie. =(A, B)=) model
conjunction, sum types (ie. =Either[A,B]=) model disjunction and
function types (ie. =A => B=) model implication. If we recast our
earlier table in terms of products, sums and functions we end up with
this,

| Scala             | First Order Logic |
|-------------------+-------------------|
| (A, B) => A       | (A ∧ B) ⇒ A       |
| (A, B) => B       | (A ∧ B) ⇒ B       |
| A => Either[A, B] | A ⇒ (A ∨ B)       |
| B => Either[A, B] | B ⇒ (A ∨ B)       |

On the left hand side we're no longer looking for validity with
respect to the subtype relation, instead we're looking for *evidence
of the principle of parametricity*, which allow us to *determine if a
function type is implementable just by reading it's signature*. It's
clear that all the function signatures on the left in the table above
can be implemented -- for the first two we have an =(A, B)= pair as our
function argument, so we can easily evaluate to either A or B, using
=_1= or =_2=,

#+BEGIN_SRC scala
val conj1: ((A,B)) => A = p => p._1
val conj2: ((A,B)) => B = p => p._2
#+END_SRC

And for the last two we have either an A or a B as our function
argument, so we can evaluate to =Either[A,B]= (as =Left[A]= or
=Right[B]= respectively).

#+BEGIN_SRC scala
val disj1: A => Either[A,B] = a => Left(a)
val disj2: B => Either[A,B] = b => Right(b)
#+END_SRC

This is the form in which the Curry-Howard isomorphism is typically
expressed *for languages without subtyping*. Because *this mapping
doesn't reflect subtype relations* it isn't going to be much direct
use to us for expressing union types which, like intersection types,
are inherently characterized in terms of subtyping. But it can help us
out with negation, which is the missing piece that we need.

Either with or without subtyping, the bottom type (Scala =Nothing=
type) maps to logical falsehood, so for example, the following
equivalences all hold,

| Scala                   | First Order Logic |
|-------------------------+-------------------|
| A => Either[A, Nothing] | A ⇒ (A ∨ false)   |
| B => Either[Nothing, B] | B ⇒ (false ∨ B)   |

because the function signatures on the left are once again all
implementable, and the logical formulae on the right are again all
valid. Now we need to think about what a function signature like,

#+BEGIN_SRC scala
A => Nothing
#+END_SRC

corresponds to. On the logical side of Curry-Howard this maps to =A ⇒
false=, which is equivalent to =¬A=. This seems fairly intuitively
reasonable -- *there are no values of type Nothing, so the signature A
=> Nothing can't be implemented* (other than by throwing an exception,
which isn't allowed).

Let's see what happens if we take this as our representation of the
negation of a type,

#+BEGIN_SRC scala
type ¬[A] = A => Nothing
#+END_SRC

and apply it back in the subtyping context that we started with to see
if we can now use De Morgan's laws to get the union types we're after,

#+BEGIN_SRC scala
type ∨[T, U] = ¬[¬[T] with ¬[U]]
#+END_SRC

We can test this using the Scala REPL, which will very quickly show
us that we're not quite there yet,

#+BEGIN_SRC scala
scala> type ¬[A] = A => Nothing
defined type alias $u00AC

scala> type ∨[T, U] = ¬[¬[T] with ¬[U]]
defined type alias $u2228

scala> implicitly[Int <:< (Int ∨ String)]
<console>:11: error: Cannot prove that Int <:<
  ((Int) => Nothing with (String) => Nothing) => Nothing.
       implicitly[Int <:< (Int ∨ String)]
#+END_SRC

The expression =implicitly[Int <:< (Int ∨ String)]= is asking the
compiler if it can prove that =Int= is a subtype of =Int ∨ String=,
which it would be if we had succeeded in coming up with an encoding of
union types.

So what's gone wrong? The problem is that we have transformed the
types on the right hand side of the =<:<= operator into function types
so that we can make use of the encoding of type negation as =A =>
Nothing=. This means that the union type is itself a function type.
That's clearly not consistent with Int being a subtype of it -- as the
error message from the REPL shows. To make this work, then, we also
need to transform the left hand side of the =<:<= operator into a type
which could possibly be a subtype of the type on the right. What could
that transformation be? How about double negation?

#+BEGIN_SRC scala
type ¬¬[A] = ¬[¬[A]]
#+END_SRC

Let's see what the compiler says now,

#+BEGIN_SRC scala
scala> type ¬¬[A] = ¬[¬[A]]
defined type alias $u00AC$u00AC

scala> implicitly[¬¬[Int] <:< (Int ∨ String)]
res5: <:<[((Int) => Nothing) => Nothing,
  ((Int) => Nothing with (String) => Nothing) => Nothing] = <function1>

scala> implicitly[¬¬[String] <:< (Int ∨ String)]
res6: <:<[((String) => Nothing) => Nothing,
  ((Int) => Nothing with (String) => Nothing) => Nothing] = <function1>
#+END_SRC

Bingo! =¬¬[Int]= and =¬¬[String]= are now both subtypes of =Int ∨
String=!

/Note/ *Why does this work?* Remind that =C => D <:< A => B= if =A <:<
C= because function is contravariant on parameter type and =D <:< B=
because function is covariant on return type. Thus, =¬¬[Int] <:< (Int
∨ String)= means,

#+BEGIN_VERSE
¬¬[Int] <:< (Int ∨ String) \equiv
  A => ⊥ => ⊥ <:< (A => ⊥ \land B => ⊥) => ⊥ \equiv
  (A => ⊥ \land B => ⊥) <:< A => ⊥ (True) AND ⊥ <:< ⊥ (True)
#+END_VERSE

We're almost there, but there's one remaining loose end to tie up --
we have subtype relationships which are isomorphic to the ones we want
(because =¬¬[T]= is isomorphic to =T=), but we don't yet have a way to
express those relationships with respect to the untransformed types
that we really want to work with.

We can do that by treating our =¬[T]=, =¬¬[T]= and =(T ∨ U)= as
phantom types, using them only to represent the subtype relationships
on the underlying type rather that working directly with their
values. Here's how that goes for our motivation example,

#+BEGIN_SRC scala
def size[T](t: T)(implicit ev: (¬¬[T] <:< (Int ∨ String))) = t match {
  case i: Int => i
  case s: String => s.length
}
#+END_SRC

This is using a generalized type constraint to require the compiler to
be able to prove that any =T= inferred as the argument type of the
size method must be such that it's double negation is a subtype of
=(Int ∨ String)=. That's only ever true when =T= is =Int= or
=String=, as this REPL session shows,

#+BEGIN_SRC scala
scala> def size[T](t: T)(implicit ev: (¬¬[T] <:< (Int ∨ String))) = t match {
     |   case i: Int => i
     |   case s: String => s.length
     | }
size: [T](t: T)(implicit ev: <:<[¬¬[T],∨[Int,String]])Int

scala> size(23)
res0: Int = 23

scala> size("foo")
res1: Int = 3

scala> size(1.0)
<console>:12: error: Cannot prove that ¬¬[Double] <:< ∨[Int,String].
              size(1.0)
#+END_SRC

One last little trick to finesse this slightly. The implicit evidence
parameter is syntactically a bit ugly and heavyweight, and we can
improve things a little by converting it to a context bound on the
type parameter =T= like so,

#+BEGIN_SRC scala
type |∨|[T, U] = { type λ[X] = ¬¬[X] <:< (T ∨ U) }

def size[T: (Int |∨| String)#λ](t: T) = t match {
  case i : Int => i
  case s : String => s.length
}
#+END_SRC

And there you have it -- an unboxed, statically type safe encoding of
union types in unmodified Scala!

/Note/ *Main Drawbacks* The type constraint doesn't propagate into
the method body so, within the body, =T= is viewed as an unbounded
type variable. Thus the following compile,

#+BEGIN_SRC scala
def size[T: (Int |∨| String)#λ](t: T) = t match {
  case d: Double => -1
}
#+END_SRC

It's a *definition site*, specifying the *meaning of the parameter*
but not a *usage site* specifying the *way to use the parameterized
argument*. This only works as a bound on a type parameter and
something like =Clazz[_ <: (Int ∨ String)]= doesn't work.

#+BEGIN_SRC scala
sealed abstract class A
case class B() extends A
case class C() extends A

def unexpected : Nothing = sys.error("Unexpected invocation")

// Encoding for "A is not a subtype of B"
trait <:!<[A, B]

// Uses ambiguity to rule out the cases we're trying to exclude
implicit def nsub[A, B]: A <:!< B = null
implicit def nsubAmbig1[A, B >: A]: A <:!< B = unexpected
implicit def nsubAmbig2[A, B >: A]: A <:!< B = unexpected

def f[T](t: T)(implicit ev: T <:!< C) = t
def g[T](t: T) = f(t) // Compile, proves that T <:!< C

def i[T](t: T)(implicit ev: T <:< C) = t
// def j[T](t: T) = i(t) // Doesn't compile, Cannot prove that T <:< C
#+END_SRC
